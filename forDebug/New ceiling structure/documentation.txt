19:12 2025. 12. 22.
Ceiling újragondolása
================================

Az előző verzió felépítése:

- Az első struktúra minden sugár számolásánál van meghívva, szóval a Horizontális falszámoló sugarak alapján dolgozik egyenként.

Bejövő adatok:
- int i: Az éppen számolt sugár száma - 1 (index)
- float rayAngle: Jelenlegi sugár radiánja
- float wwallHeight: A sugár-fal magassága

Struktúra:
Előredeklarálás:
=================================
- float ceilingFloorPixelDistance
- float ceilingPixelXWorldPosition
- float ceilingPixelYWorldPosition

Közös X a padlóval:
(Mivel a fal mentén lett megrajzolva a tető és padló is, így ugyanazokat az x koordinátákat használják)
- float floorCeilingPixelXLeft (X1)
- float floorCeilingPixelXRight (X2)

- float ceilingStep (Pixel magassága)

- float ceilingPixelYTop (Y1)
- float ceilingPixelYBottom (Y2)

- int cameraZ (Player magassága (A képernyő közepe))
Konstans

While ciklus (Amíg a pixel le nem "folyik" a falig, tehát csak az van kirajzolva, amit lehet látni)

- ceilingPixelYBottom (ellenőrzés)
Ha a pixel elérte a falat, a pixel alja legyen egyenlő a fal kezdésével a tökéletes illeszkedésért.

- float rowY (A jelenlegi pixel Y-ja A KÉPERNYŐN, NEM A VILÁGBAN)

- ceilingFloorPixelDistance

- ceilingPixelXWorldPosition
A Pixel X koordinátája A VILÁGBAN
- ceilingPixelYWorldPosition
A Pixel Y koordinátája A VILÁGBAN

- int[][] path = null (Biztonsági deklarálás)
A path legyen null defaultként, mert ha lenne ott kirajzolható pixel, a TextureTranslator() amugy is megváltoztatná.

- TextureTranslator(int[,])
Textúra hozzárendelés

- if - continue
Ha a "path" null maradt, lépjen a következő pixelre/ciklusra

- int RGBCalc
Elavult és sokszor hibás/lassú matek a pixel keresésére a textúrában

- float shadeCalc
A távolság alapján számolt árnyék mértéke
(Egy szám amit egységesen kell kivonni RGB-ből)

- vertex feltöltés
X1
X2
Y1
Y2
R
G
B

ceilingPixelYTop = ceilingPixelYBottom;
ceilingPixelYBottom += ceilingStep;
(Y koordináta inkrementálás a következő pixelhez)

Vélemény:
=========
A fent feltüntetett dátumig ezt a logikát használtam a tető kirajzolására, és ennek az invertált logikáját a padlóra.
Miért nem jó:
- LASSÚ: Mivel nincs kézreeső érték amivel ésszerűen lehetne megadni a pixelek magasságát, saját értéket adtam meg. Ha konzisztens akarok maradni a fallal, zabálja az fps-t, mert hiába, hogy a pixelek méretei megegyeznek a faléval, a fal csíkját lehet textúra mérethez kötötten rajzolni, így egy csík 36 számolás csak, de itt nem lehet a nem konzisztens és nem egyenes tetőre való rálátás miatt.
- Túl nagy ciklus: Mivel ez a rendszer olyan értékekre alapszik, ami minden sugárszámolásnál külön egyenként van jelen, muszáj hogy a "nagy" for ciklus része legyen.

Megoldás:
=========
Szeretnék csinálni egy olyan strujtúrát, ami egy külön raycasting logikát használ a padlóhoz és tetőhöz. Ahelyett, hogy a falakhoz hasonló vertikális vonalakkal rajzolom ki a tetőt, a lépernyő tetejétől lefelé horizontális vonalakkal oldom meg. Bár lehet, hogy elenyésző mennyiségő nem kellő számolás és rajzolás lesz így, mert horizontális vonalakkal nem tudom hozzáigazítani a tető pixeleit a fal tetejéhez. Ez azt jelent, hogy mintha nem lenne fal, a render distanceig, VAGY a mapban lévő tetőig minden tetőt kirajzolok, és utána rárajzolom a falat.
Ez megengedné nekem, hogy balról jobbra haladva egy csíkban egy egyenés y vagy x koordinátát használva textúra pixelenként lépkedjek mint a falaknál.
- Ehhez az elgondolásom szerint nekem interpolálnom kelene egy második sugármennyiséget, ami a képernyő y-ján oszlik el vertikálisan.
Pl.: 1920 a képernyő szélessége, és a rá vetett horizontálisan egymás melett lévő sugarak mennyisége 500, akkor 1920/500 = 4~ pixel jut egy sugárnak a képernyőn. Itt 4/1080 = 270~ sugarat jelentene a méreteket nézve vertikálisan egymás mellett a képernyő Y-ján.
- a rowY-t elég lenne soronként újraszámolni, mivel csak soronként változik a pixel KÉPERNYŐN lévő y-ja.
- a ceilingFloorPixelDistance problémás egy kicsit. Ő a jelenlegi horizontális sugarak radiánját használja.
MÉG ŐT NEM TUDOM HOGY SZÁMOLJAM KI!!!

Jelenlegi helyzet:
((cameraZ / rowY) * tileSize) / (float)Math.Cos(playerAngle - rayAngle);

Az első felét nem kell változtatni, mivel a cameraZ konstans értéke, és a rowY, ami a képernyő y-ját mutatja, nem problémásak.

(float)Math.Cos(playerAngle - rayAngle):
Nem csak fisheye-fix, hanem érdekes tető hullámzás megelőzése ennek a kettő párosnak a különbsége.
!!!Ki fogom próbálni, hogy mi van ha újrakreálom az 500 sugár egyenkénti radiánját, hogy mit mutat teljesítményben és minőségben. De lehetséges, hogy kellene még egy 270~ sugarat interpolálni ugyanugy, mint az 500 van.

Ha ez működik, a világpozícióval sem lesz gond szerintem

ceilingPixelXWorldPosition, ceilingPixelYWorldPosition
UGYANEZ, MIVEL A TÁVOLSÁG VÁLTOZÓN ALAPSZANAK